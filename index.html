<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Marshall Ward">
  <meta name="dcterms.date" content="2021-04-21">
  <title>The Vectorization of MOM6</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/gfdl.css" id="theme">
  <!-- Explicitly add zenburn for highlight support -->
  <link rel="stylesheet" href="./reveal.js/plugin/highlight/zenburn.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.scss' : './reveal.js/css/print/paper.scss';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <base href="./index.html">
</head>
<body>
  <div class="reveal"
       style="background: url(img/bg_gfdl.jpg);
              background-size: cover;">

    <!-- Original ratio: 10.04" x 7.08" -->
    <div style="height: 100vh; position: absolute; bottom: -50vh; left: -40vh">
      <img style="height: 100vh; width: 142vh" src="img/bg_globe.png">
    </div>

    <header style="width: 10vh; position: absolute; bottom: 2vh; right: 2vh;">
      <img src="img/noaa_logo.png">
    </header>

    <footer style="font-size: 1pc; position: absolute; bottom: 2%; left: 2%;">
      <code><p><a href="https://marshallward.org/ogrp2021.html">https://marshallward.org/ogrp2021.html</a></p></code>
    </footer>

    <div class="slides">

<section id="title-slide">
  <!--div class="reveal" style="text-align: right;">
    <img src="img/noaa_logo.png"
         style="background: none; border: none; box-shadow: none;
         width: 30%"
         alt="NCI">
  </div-->
  <h1 class="title">The Vectorization of MOM6</h1>
  <p class="author" style="text-align: right;">Marshall Ward</p>
  <p class="date" style="text-align: right;">2021-04-21</p>
  <!-- Currently cannot add notes to a title slide, so have to do manually-->
  <aside class="notes">
    
  </aside>
</section>

<section id="peak-performance" class="title-slide slide level1">
<h1>Peak Performance</h1>
<p><span class="math display">\[W \le N \times f \times I_\text{vec}\]</span></p>
<table>
<tbody>
<tr class="odd">
<td><span class="math inline">\(W\)</span></td>
<td>FLOPs per second ("work")</td>
</tr>
<tr class="even">
<td><span class="math inline">\(N\)</span></td>
<td># of CPUs</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(f\)</span></td>
<td>Cycles per second</td>
</tr>
<tr class="even">
<td><span class="math inline">\(I_\text{vec}\)</span></td>
<td>FLOPs per cycle</td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>This is a form of the so-called "iron law" of peak performance.</p>
<p>It is normally written as an expression of time, rather than rate of work, but I think this inverse form is better suited for this discussion.</p>
<p>The "work" here is written as the number of FLOPs (or floating point operations) per second, but it could be generalized to other units computational work.</p>
<p>The first two terms are very straightforward: N is the number of CPUs and f is the clock rate, or cycles per second. More CPUs and faster clock rate means more work.</p>
<p>The third term here is more interesting, and is the focus here. This represents the ability of the CPU to do concurrent work on a single core.</p>
</aside>
</section>

<section>
<section id="cpu-scaling" class="title-slide slide level1">
<h1>CPU Scaling</h1>
<p><img data-src="img/scaling_ocn.svg" alt="image" /></p>
<p>MOM5 scaling in ACCESS-OM2</p>
</section>
<section id="fluid-dynamics-scaling" class="slide level2">
<h2>Fluid Dynamics Scaling</h2>
<p>Tension between local (hyperbolic) solvers</p>
<p><span class="math display">\[\begin{aligned}
\frac{\partial \mathbf{u}}{\partial t}
   &amp;= -\mathbf{u} \cdot \nabla \mathbf{u} - \nabla p + \mathbf{f} \\
\end{aligned}\]</span></p>
<p>and global (elliptic) solvers</p>
<p><span class="math display">\[\begin{aligned}
\nabla^2 p
   &amp;= -\nabla \cdot \left( \mathbf{u} \cdot \nabla \mathbf{u} \right)
      + \nabla \cdot \mathbf{F} \\
   &amp;\approx \nabla \cdot \mathbf{F} \text{(?)} \\
\end{aligned}\]</span></p>
<p>... unless you can cheat (aka oceanography)</p>
</section></section>
<section>
<section id="clock-speed" class="title-slide slide level1">
<h1>Clock Speed</h1>
<p><img data-src="img/clockspeed.svg" style="width:70.0%" alt="image" /></p>
<aside class="notes">
<p>This is a plot of CPU clock speeds from CPUDB. The database goes from about 1970 to 2014, but the situation has not changed much since then.</p>
<p>The trend is clear: Clock speed increased exponentially until about 2005. After that, it flattened out around 3GHz. After that, people stopped talking much about clock speeds.</p>
<p>This is a reflection of Moore's law (transistor rate) but is better explained by the breakdown of Dennard scaling.</p>
<ul>
<li>P ~ f</li>
<li>P/A ~ const</li>
<li>transitor density drops exponentially =&gt; power drops too</li>
<li>=&gt; increase f to balance P</li>
</ul>
<p>After 2005, thermal leakage led to P &gt;&gt; A</p>
</aside>
</section>
<section id="clock-speed-vs-of-cores" class="slide level2">
<h2>Clock Speed vs # of Cores</h2>
<p>Using more cores further reduces clock speed!</p>
</section></section>
<section>
<section id="vectorization" class="title-slide slide level1">
<h1>Vectorization</h1>
<p><img data-src="img/specfp.svg" alt="image" /></p>
<aside class="notes">
<p>:</p>
<p>Main comments:</p>
<ul>
<li><p>Despite the end of clock speed increase, FP rates continue to rise</p></li>
<li><p>But after ~2004, the rate definitely drops. What causes it?</p></li>
<li><p>Less important: What happened in the 90s?</p>
<p>This was the era of high-end vector CPUs (DEC, SPARC, etc). As they failed to keep up with commodity x86 chips, they left the market.</p></li>
<li><p>Even less important: The "blob" at the end is emergence of mobile chips?</p></li>
</ul>
<p>What is SPECfp?</p>
<p>This is a renormalized plot of the SPECfp scores over time.</p>
<p>CPUs are assigned a "score" based on their performance of a suite of FP-based models. The number is somewhat arbitrary.</p>
<p>Unfortunately they periodically change these tests and SPEC strongly discourages comparison across tests, but in the words of Jurgen Willebrand, no one can stop me!</p>
<p>We roughly normalize along Intel trends, especially 95-&gt;2k, which is why the "high end" cloud permeates.</p>
<p>Don't take these numbers too literally, especially my renormalization which I didn't properly calibrate.</p>
</aside>
</section>
<section id="intel-normalization" class="slide level2">
<h2>Intel normalization</h2>
<p><img data-src="img/specfp_intel.svg" alt="image" /></p>
<aside class="notes">
<p>Showing the normalization of Intel-based architectures.</p>
</aside>
</section></section>
<section id="vector-instructions" class="title-slide slide level1">
<h1>Vector Instructions</h1>
<p><img data-src="img/avx.svg" alt="image" /></p>
<table>
<thead>
<tr class="header">
<th>Instr.</th>
<th>Size</th>
<th>GFLOP/s</th>
<th>Obs. (Gaea)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SSE</td>
<td>4 SP/2 DP</td>
<td>14.4</td>
<td>14.394</td>
</tr>
<tr class="even">
<td>AVX</td>
<td>8 SP/4 DP</td>
<td>28.8</td>
<td>28.790</td>
</tr>
</tbody>
</table>
</section>

<section id="fused-multiply-add" class="title-slide slide level1">
<h1>Fused-Multiply Add</h1>
<p>FMA: <span class="math inline">\(d \leftarrow a \times b + c\)</span></p>
<table>
<thead>
<tr class="header">
<th>Instr.</th>
<th>Op</th>
<th>GFLOP/s</th>
<th>Obs.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>SSE</p></td>
<td><p>Add</p>
<p>FMA</p></td>
<td><p>14.4</p>
<p>28.8</p></td>
<td><p>14.394</p>
<p>28.790</p></td>
</tr>
<tr class="even">
<td><p>AVX</p></td>
<td><p>Add</p>
<p>FMA</p></td>
<td><p>28.8</p>
<p>57.6</p></td>
<td><p>28.788</p>
<p>57.580</p></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(\text{rd}(\text{rd}(a \times b) + c)\)</span> vs <span class="math inline">\(\text{rd}(a \times b + c)\)</span></p>
</section>

<section id="concurrency" class="title-slide slide level1">
<h1>Concurrency</h1>
<p><img data-src="img/broadwell_exc.svg" alt="image" /></p>
<p>2 instr. per cycle, even FMA</p>
</section>

<section id="peak" class="title-slide slide level1">
<h1>Peak</h1>
<table>
<thead>
<tr class="header">
<th>Instr.</th>
<th>Op</th>
<th>GFLOP/s</th>
<th>Obs.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>SSE</p></td>
<td><p>Add</p>
<p>FMA</p>
<p>2x FMA</p></td>
<td><p>14.4</p>
<p>28.8</p>
<p>57.6</p></td>
<td><p>14.394</p>
<p>28.790</p>
<p>57.580</p></td>
</tr>
<tr class="even">
<td><p>AVX</p></td>
<td><p>Add</p>
<p>Add+Mul</p>
<p>FMA</p>
<p>2x FMA</p></td>
<td><p>28.8</p>
<p>57.6</p>
<p>57.6</p>
<p>115.2</p></td>
<td><p>28.788</p>
<p>57.580</p>
<p>57.580</p>
<p>115.160</p></td>
</tr>
</tbody>
</table>
</section>

<section id="array-ops" class="title-slide slide level1">
<h1>Array Ops</h1>
<p><img data-src="img/gaea_flops.svg" alt="image" /></p>
</section>

<section id="array-ops-1" class="title-slide slide level1">
<h1>Array Ops</h1>
<p><img data-src="img/gaea_flops_cached.svg" alt="image" /></p>
</section>

<section id="arrays-amd" class="title-slide slide level1">
<h1>Arrays @ AMD</h1>
<p><img data-src="img/zen3_flops.svg" alt="image" /></p>
</section>

<section id="arrays-amd-1" class="title-slide slide level1">
<h1>Arrays @ AMD</h1>
<p><img data-src="img/zen3_flops_cached.svg" alt="image" /></p>
</section>

<section id="arithmetic-intensity" class="title-slide slide level1">
<h1>Arithmetic Intensity</h1>
<table>
<thead>
<tr class="header">
<th>Expression</th>
<th>AI</th>
<th>Max GFLOP/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>y[:] = a x[:]</td>
<td><span class="math inline">\(\frac{1}{4}\)</span></td>
<td>26.43</td>
</tr>
<tr class="even">
<td>y[:] = x[:] + x[:]</td>
<td><span class="math inline">\(\frac{1}{4}\)</span></td>
<td>24.98</td>
</tr>
<tr class="odd">
<td>y[:] = x[:] + y[:]</td>
<td><span class="math inline">\(\frac{1}{8}\)</span></td>
<td>18.34</td>
</tr>
<tr class="even">
<td>y[:] = a x[:] + y[:]</td>
<td><span class="math inline">\(\frac{1}{4}\)</span></td>
<td>37.58</td>
</tr>
<tr class="odd">
<td>y[:] = a x[:] + b y[:]</td>
<td><span class="math inline">\(\frac{3}{8}\)</span></td>
<td>51.08</td>
</tr>
<tr class="even">
<td>y[:] = x[1:] - x[:-1]</td>
<td><span class="math inline">\(\frac{1}{8}\)</span></td>
<td>14.07</td>
</tr>
<tr class="odd">
<td>y[:] = x[8:] - x[:-8]</td>
<td><span class="math inline">\(\frac{1}{8}\)</span></td>
<td>18.39</td>
</tr>
</tbody>
</table>
</section>

<section id="mom6-sample-config" class="title-slide slide level1">
<h1>MOM6 sample config</h1>
<p><img data-src="img/benchmark_topo.svg" class="float float" style="width:35.0%" alt="image" /></p>
<ul>
<li><p>32 × 32 grid, 75 level</p>
<ul>
<li class="fragment">~76k / field</li>
</ul></li>
<li><p>288 steps (3 day, <span class="math inline">\(\Delta t = 900s\)</span>)</p></li>
<li><p>"Benchmark" configuration:</p>
<ul>
<li class="fragment">Split barotropic</li>
<li class="fragment">Biharmonic visc</li>
<li class="fragment">Thickness diffusivity</li>
<li class="fragment">Bounded Coriolis</li>
<li class="fragment">??</li>
</ul></li>
</ul>
</section>

<section id="profiling-with-perf" class="title-slide slide level1">
<h1>Profiling with perf</h1>
<p><img data-src="img/perf_symbols.png" style="width:80.0%" alt="image" /></p>
</section>

<section id="profiling-with-perf-1" class="title-slide slide level1">
<h1>Profiling with perf</h1>
<p><img data-src="img/perf_lines.png" style="width:80.0%" alt="image" /></p>
</section>

<section id="perf-stat" class="title-slide slide level1">
<h1>perf stat</h1>
<pre class="" data-code=""><code>Performance counter stats for &#39;../../build/intel/MOM6&#39;:

    22397.33 msec task-clock:u              # 0.986 CPUs utilized
 84092282119      cycles:u                  # 3.755 GHz
 45781959071      stalled-cycles-backend:u  # 54.44% idle cycles
 11481435369      l2_cycles_waiting_on_fills:u #  512.625 M/sec
 59207044954      fp_ret_sse_avx_ops.all:u  # 2643.487 M/sec

 22.709657811 seconds time elapsed

 22.232343000 seconds user
  0.116333000 seconds sys
</code></pre>
</section>

<section id="mom6-flop-rates" class="title-slide slide level1">
<h1>MOM6 FLOP rates</h1>
<p><img data-src="img/subroutine_share.svg" alt="image" /></p>
</section>

<section id="horizontal-viscosity" class="title-slide slide level1">
<h1>Horizontal Viscosity</h1>
<pre class=" numberLines" data-code="" data-start-line="831

" data-end-line="958

" data-line-numbers="1|2-6|7-13|14-18|20-73|127

" data-startFrom="831

"><code>    do j=Jsq,Jeq+1 ; do i=Isq,Ieq+1
      if ((CS%Smagorinsky_Kh) .or. (CS%Smagorinsky_Ah)) then
        Shear_mag = sqrt(sh_xx(i,j)*sh_xx(i,j) + &amp;
          0.25*((sh_xy(I-1,J-1)*sh_xy(I-1,J-1) + sh_xy(I,J)*sh_xy(I,J)) + &amp;
                (sh_xy(I-1,J)*sh_xy(I-1,J) + sh_xy(I,J-1)*sh_xy(I,J-1))))
      endif
      if ((CS%Leith_Kh) .or. (CS%Leith_Ah)) then
        if (CS%use_QG_Leith_visc) then
          vert_vort_mag = MIN(grad_vort_mag_h(i,j) + grad_div_mag_h(i,j),3.*grad_vort_mag_h_2d(i,j))
        else
          vert_vort_mag = (grad_vort_mag_h(i,j) + grad_div_mag_h(i,j))
        endif
      endif
      if (CS%better_bound_Ah .or. CS%better_bound_Kh) then
        hrat_min = min(1.0, min(h_u(I,j), h_u(I-1,j), h_v(i,J), h_v(i,J-1)) / &amp;
                            (h(i,j,k) + h_neglect) )
        visc_bound_rem = 1.0
      endif

      if (CS%Laplacian) then
        ! Determine the Laplacian viscosity at h points, using the
        ! largest value from several parameterizations.
        Kh = CS%Kh_bg_xx(i,j) ! Static (pre-computed) background viscosity
        if (CS%add_LES_viscosity) then
          if (CS%Smagorinsky_Kh) Kh = Kh + CS%Laplac2_const_xx(i,j) * Shear_mag
          if (CS%Leith_Kh) Kh = Kh + CS%Laplac3_const_xx(i,j) * vert_vort_mag*inv_PI3
        else
          if (CS%Smagorinsky_Kh) Kh = max( Kh, CS%Laplac2_const_xx(i,j) * Shear_mag )
          if (CS%Leith_Kh) Kh = max( Kh, CS%Laplac3_const_xx(i,j) * vert_vort_mag*inv_PI3)
        endif
        ! All viscosity contributions above are subject to resolution scaling
        if (rescale_Kh) Kh = VarMix%Res_fn_h(i,j) * Kh
        if (CS%res_scale_MEKE) meke_res_fn = VarMix%Res_fn_h(i,j)
        ! Older method of bounding for stability
        if (legacy_bound) Kh = min(Kh, CS%Kh_Max_xx(i,j))
        Kh = max( Kh, CS%Kh_bg_min ) ! Place a floor on the viscosity, if desired.
        if (use_MEKE_Ku) &amp;
          Kh = Kh + MEKE%Ku(i,j) * meke_res_fn ! *Add* the MEKE contribution (might be negative)
        if (CS%anisotropic) Kh = Kh + CS%Kh_aniso * ( 1. - CS%n1n2_h(i,j)**2 ) ! *Add* the tension component
                                                                               ! of anisotropic viscosity

        ! Newer method of bounding for stability
        if (CS%better_bound_Kh) then
          if (Kh &gt;= hrat_min*CS%Kh_Max_xx(i,j)) then
            visc_bound_rem = 0.0
            Kh = hrat_min*CS%Kh_Max_xx(i,j)
          else
            visc_bound_rem = 1.0 - Kh / (hrat_min*CS%Kh_Max_xx(i,j))
          endif
        endif

        if ((CS%id_Kh_h&gt;0) .or. find_FrictWork .or. CS%debug) Kh_h(i,j,k) = Kh

        if (CS%id_grid_Re_Kh&gt;0) then
          KE = 0.125*((u(I,j,k)+u(I-1,j,k))**2 + (v(i,J,k)+v(i,J-1,k))**2)
          grid_Re_Kh(i,j,k) = (sqrt(KE) * sqrt(CS%grid_sp_h2(i,j))) &amp;
              / max(Kh, CS%min_grid_Kh)
        endif

        if (CS%id_div_xx_h&gt;0) div_xx_h(i,j,k) = div_xx(i,j)
        if (CS%id_sh_xx_h&gt;0) sh_xx_h(i,j,k) = sh_xx(i,j)

        str_xx(i,j) = -Kh * sh_xx(i,j)
      else   ! not Laplacian
        str_xx(i,j) = 0.0
      endif ! Laplacian

      if (CS%anisotropic) then
        ! Shearing-strain averaged to h-points
        local_strain = 0.25 * ( (sh_xy(I,J) + sh_xy(I-1,J-1)) + (sh_xy(I-1,J) + sh_xy(I,J-1)) )
        ! *Add* the shear-strain contribution to the xx-component of stress
        str_xx(i,j) = str_xx(i,j) - CS%Kh_aniso * CS%n1n2_h(i,j) * CS%n1n1_m_n2n2_h(i,j) * local_strain
      endif

      if (CS%biharmonic) then
        ! Determine the biharmonic viscosity at h points, using the
        ! largest value from several parameterizations.
        AhSm = 0.0; AhLth = 0.0
        if ((CS%Smagorinsky_Ah) .or. (CS%Leith_Ah)) then
          if (CS%Smagorinsky_Ah) then
            if (CS%bound_Coriolis) then
              AhSm = Shear_mag * (CS%Biharm_const_xx(i,j) + &amp;
                                  CS%Biharm_const2_xx(i,j)*Shear_mag)
            else
              AhSm = CS%Biharm_const_xx(i,j) * Shear_mag
            endif
          endif
          if (CS%Leith_Ah) AhLth = CS%Biharm6_const_xx(i,j) * abs(Del2vort_h(i,j)) * inv_PI6
          Ah = MAX(MAX(CS%Ah_bg_xx(i,j), AhSm), AhLth)
          if (CS%bound_Ah .and. .not.CS%better_bound_Ah) &amp;
            Ah = MIN(Ah, CS%Ah_Max_xx(i,j))
        else
          Ah = CS%Ah_bg_xx(i,j)
        endif ! Smagorinsky_Ah or Leith_Ah

        if (use_MEKE_Au) Ah = Ah + MEKE%Au(i,j) ! *Add* the MEKE contribution

        if (CS%Re_Ah &gt; 0.0) then
          KE = 0.125*((u(I,j,k)+u(I-1,j,k))**2 + (v(i,J,k)+v(i,J-1,k))**2)
          Ah = sqrt(KE) * CS%Re_Ah_const_xx(i,j)
        endif

        if (CS%better_bound_Ah) then
          Ah = MIN(Ah, visc_bound_rem*hrat_min*CS%Ah_Max_xx(i,j))
        endif

        if ((CS%id_Ah_h&gt;0) .or. find_FrictWork .or. CS%debug) Ah_h(i,j,k) = Ah

        if (CS%id_grid_Re_Ah&gt;0) then
          KE = 0.125*((u(I,j,k)+u(I-1,j,k))**2 + (v(i,J,k)+v(i,J-1,k))**2)
          grid_Re_Ah(i,j,k) = (sqrt(KE) * CS%grid_sp_h3(i,j)) &amp;
              / max(Ah, CS%min_grid_Ah)
        endif

        str_xx(i,j) = str_xx(i,j) + Ah * &amp;
          (CS%DY_dxT(i,j) * (G%IdyCu(I,j)*Del2u(I,j) - G%IdyCu(I-1,j)*Del2u(I-1,j)) - &amp;
           CS%DX_dyT(i,j) * (G%IdxCv(i,J)*Del2v(i,J) - G%IdxCv(i,J-1)*Del2v(i,J-1)))

        ! Keep a copy of the biharmonic contribution for backscatter parameterization
        bhstr_xx(i,j) = Ah * &amp;
          (CS%DY_dxT(i,j) * (G%IdyCu(I,j)*Del2u(I,j) - G%IdyCu(I-1,j)*Del2u(I-1,j)) - &amp;
           CS%DX_dyT(i,j) * (G%IdxCv(i,J)*Del2v(i,J) - G%IdxCv(i,J-1)*Del2v(i,J-1)))
        bhstr_xx(i,j) = bhstr_xx(i,j) * (h(i,j,k) * CS%reduction_xx(i,j))

      endif  ! biharmonic

    enddo ; enddo
</code></pre>
</section>

<section id="non-vectorized-code" class="title-slide slide level1">
<h1>Non-vectorized code</h1>
<pre class="x86asm"><code>│      │833    Shear_mag = sqrt(sh_xx(i,j)*sh_xx(i,j) + &amp;
│ 0.70 │         vaddsd   %xmm13,%xmm12,%xmm14
│ 1.62 │         vsqrtsd  %xmm14,%xmm14,%xmm14
│ 6.53 │         vmovsd   %xmm14,-0x8e8(%rbp)</code></pre>
<table>
<tbody>
<tr class="odd">
<td><code>v___sd</code></td>
<td>Serial</td>
</tr>
<tr class="even">
<td><code>v___pd</code></td>
<td>Parallel</td>
</tr>
</tbody>
</table>
</section>

<section id="excessive-stack" class="title-slide slide level1">
<h1>Excessive Stack</h1>
<pre class="x86asm"><code>│      │919    Ah = MAX(MAX(CS%Ah_bg_xx(i,j), AhSm), AhLth)
│      │         lea      (%rax,%rdx,8),%rdi
│      │         lea      (%rdi,%rsi,1),%r8
│ 0.39 │         vmovsd   (%r8,%r9,8),%xmm0
│ 0.01 │         vmaxsd   -0x13f8(%rbp),%xmm0,%xmm0
│ 2.34 │         vmaxsd   -0x13f0(%rbp),%xmm0,%xmm0
│ 0.42 │         vmovsd   %xmm0,-0x1468(%rbp)</code></pre>
<table>
<tbody>
<tr class="odd">
<td>lea</td>
<td>Compute mem address</td>
</tr>
<tr class="even">
<td>vmovsd</td>
<td>Serial move</td>
</tr>
<tr class="odd">
<td>vmaxsd</td>
<td>Serial max</td>
</tr>
</tbody>
</table>
</section>

<section id="hor-visc-speedup" class="title-slide slide level1">
<h1>Hor Visc Speedup</h1>
<table>
<thead>
<tr class="header">
<th>Platform</th>
<th>Old</th>
<th>New</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Gaea C4</p></td>
<td><p>2.23s</p>
<p>(1.67)</p></td>
<td><p>1.27s</p>
<p>(2.93)</p></td>
<td><p>1.75x</p></td>
</tr>
<tr class="even">
<td><p>Ryzen 5 2600</p></td>
<td><p>1.69s</p>
<p>(2.30)</p></td>
<td><p>1.01s</p>
<p>(3.76)</p></td>
<td><p>1.67x</p></td>
</tr>
</tbody>
</table>
</section>

<section id="coriolis-advection" class="title-slide slide level1">
<h1>Coriolis advection</h1>
<pre class=" numberLines" data-code="" data-start-line="424

" data-end-line="686

" data-line-numbers="1|17-32|245-257

" data-startFrom="424

"><code>    do J=Jsq-1,Jeq+1 ; do I=Isq-1,Ieq+1
      if (CS%no_slip ) then
        relative_vorticity = (2.0-G%mask2dBu(I,J)) * (dvdx(I,J) - dudy(I,J)) * G%IareaBu(I,J)
      else
        relative_vorticity = G%mask2dBu(I,J) * (dvdx(I,J) - dudy(I,J)) * G%IareaBu(I,J)
      endif
      absolute_vorticity = G%CoriolisBu(I,J) + relative_vorticity
      Ih = 0.0
      if (Area_q(i,j) &gt; 0.0) then
        hArea_q = (hArea_u(I,j) + hArea_u(I,j+1)) + (hArea_v(i,J) + hArea_v(i+1,J))
        Ih = Area_q(i,j) / (hArea_q + h_neglect*Area_q(i,j))
      endif
      q(I,J) = absolute_vorticity * Ih
      abs_vort(I,J) = absolute_vorticity
      Ih_q(I,J) = Ih

      if (CS%bound_Coriolis) then
        fv1 = absolute_vorticity * v(i+1,J,k)
        fv2 = absolute_vorticity * v(i,J,k)
        fu1 = -absolute_vorticity * u(I,j+1,k)
        fu2 = -absolute_vorticity * u(I,j,k)
        if (fv1 &gt; fv2) then
          max_fvq(I,J) = fv1 ; min_fvq(I,J) = fv2
        else
          max_fvq(I,J) = fv2 ; min_fvq(I,J) = fv1
        endif
        if (fu1 &gt; fu2) then
          max_fuq(I,J) = fu1 ; min_fuq(I,J) = fu2
        else
          max_fuq(I,J) = fu2 ; min_fuq(I,J) = fu1
        endif
      endif

      if (CS%id_rv &gt; 0) RV(I,J,k) = relative_vorticity
      if (CS%id_PV &gt; 0) PV(I,J,k) = q(I,J)
      if (associated(AD%rv_x_v) .or. associated(AD%rv_x_u)) &amp;
        q2(I,J) = relative_vorticity * Ih
    enddo ; enddo

    !   a, b, c, and d are combinations of neighboring potential
    ! vorticities which form the Arakawa and Hsu vorticity advection
    ! scheme.  All are defined at u grid points.

    if (CS%Coriolis_Scheme == ARAKAWA_HSU90) then
      do j=Jsq,Jeq+1
        do I=is-1,Ieq
          a(I,j) = (q(I,J) + (q(I+1,J) + q(I,J-1))) * C1_12
          d(I,j) = ((q(I,J) + q(I+1,J-1)) + q(I,J-1)) * C1_12
        enddo
        do I=Isq,Ieq
          b(I,j) = (q(I,J) + (q(I-1,J) + q(I,J-1))) * C1_12
          c(I,j) = ((q(I,J) + q(I-1,J-1)) + q(I,J-1)) * C1_12
        enddo
      enddo
    elseif (CS%Coriolis_Scheme == ARAKAWA_LAMB81) then
      do j=Jsq,Jeq+1 ; do I=Isq,Ieq+1
        a(I-1,j) = (2.0*(q(I,J) + q(I-1,J-1)) + (q(I-1,J) + q(I,J-1))) * C1_24
        d(I-1,j) = ((q(I,j) + q(I-1,J-1)) + 2.0*(q(I-1,J) + q(I,J-1))) * C1_24
        b(I,j) =   ((q(I,J) + q(I-1,J-1)) + 2.0*(q(I-1,J) + q(I,J-1))) * C1_24
        c(I,j) =   (2.0*(q(I,J) + q(I-1,J-1)) + (q(I-1,J) + q(I,J-1))) * C1_24
        ep_u(i,j) = ((q(I,J) - q(I-1,J-1)) + (q(I-1,J) - q(I,J-1))) * C1_24
        ep_v(i,j) = (-(q(I,J) - q(I-1,J-1)) + (q(I-1,J) - q(I,J-1))) * C1_24
      enddo ; enddo
    elseif (CS%Coriolis_Scheme == AL_BLEND) then
      Fe_m2 = CS%F_eff_max_blend - 2.0
      rat_lin = 1.5 * Fe_m2 / max(CS%wt_lin_blend, 1.0e-16)

      ! This allows the code to always give Sadourny Energy
      if (CS%F_eff_max_blend &lt;= 2.0) then ; Fe_m2 = -1. ; rat_lin = -1.0 ; endif

      do j=Jsq,Jeq+1 ; do I=Isq,Ieq+1
        min_Ihq = MIN(Ih_q(I-1,J-1), Ih_q(I,J-1), Ih_q(I-1,J), Ih_q(I,J))
        max_Ihq = MAX(Ih_q(I-1,J-1), Ih_q(I,J-1), Ih_q(I-1,J), Ih_q(I,J))
        rat_m1 = 1.0e15
        if (max_Ihq &lt; 1.0e15*min_Ihq) rat_m1 = max_Ihq / min_Ihq - 1.0
        ! The weights used here are designed to keep the effective Coriolis
        ! acceleration from any one point on its neighbors within a factor
        ! of F_eff_max.  The minimum permitted value is 2 (the factor for
        ! Sadourny&#39;s energy conserving scheme).

        ! Determine the relative weights of Arakawa &amp; Lamb vs. Arakawa and Hsu.
        if (rat_m1 &lt;= Fe_m2) then ; AL_wt = 1.0
        elseif (rat_m1 &lt; 1.5*Fe_m2) then ; AL_wt = 3.0*Fe_m2 / rat_m1 - 2.0
        else ; AL_wt = 0.0 ; endif

        ! Determine the relative weights of Sadourny Energy vs. the other two.
        if (rat_m1 &lt;= 1.5*Fe_m2) then ; Sad_wt = 0.0
        elseif (rat_m1 &lt;= rat_lin) then
          Sad_wt = 1.0 - (1.5*Fe_m2) / rat_m1
        elseif (rat_m1 &lt; 2.0*rat_lin) then
          Sad_wt = 1.0 - (CS%wt_lin_blend / rat_lin) * (rat_m1 - 2.0*rat_lin)
        else ; Sad_wt = 1.0 ; endif

        a(I-1,j) = Sad_wt * 0.25 * q(I-1,J) + (1.0 - Sad_wt) * &amp;
                   ( ((2.0-AL_wt)* q(I-1,J) + AL_wt*q(I,J-1)) + &amp;
                      2.0 * (q(I,J) + q(I-1,J-1)) ) * C1_24
        d(I-1,j) = Sad_wt * 0.25 * q(I-1,J-1) + (1.0 - Sad_wt) * &amp;
                   ( ((2.0-AL_wt)* q(I-1,J-1) + AL_wt*q(I,J)) + &amp;
                      2.0 * (q(I-1,J) + q(I,J-1)) ) * C1_24
        b(I,j) =   Sad_wt * 0.25 * q(I,J) + (1.0 - Sad_wt) * &amp;
                   ( ((2.0-AL_wt)* q(I,J) + AL_wt*q(I-1,J-1)) + &amp;
                      2.0 * (q(I-1,J) + q(I,J-1)) ) * C1_24
        c(I,j) =   Sad_wt * 0.25 * q(I,J-1) + (1.0 - Sad_wt) * &amp;
                   ( ((2.0-AL_wt)* q(I,J-1) + AL_wt*q(I-1,J)) + &amp;
                      2.0 * (q(I,J) + q(I-1,J-1)) ) * C1_24
        ep_u(i,j) = AL_wt  * ((q(I,J) - q(I-1,J-1)) + (q(I-1,J) - q(I,J-1))) * C1_24
        ep_v(i,j) = AL_wt * (-(q(I,J) - q(I-1,J-1)) + (q(I-1,J) - q(I,J-1))) * C1_24
      enddo ; enddo
    endif

    if (CS%Coriolis_En_Dis) then
    !  c1 = 1.0-1.5*RANGE ; c2 = 1.0-RANGE ; c3 = 2.0 ; slope = 0.5
      c1 = 1.0-1.5*0.5 ; c2 = 1.0-0.5 ; c3 = 2.0 ; slope = 0.5

      do j=Jsq,Jeq+1 ; do I=is-1,ie
        uhc = uh_center(I,j)
        uhm = uh(I,j,k)
        ! This sometimes matters with some types of open boundary conditions.
        if (G%dy_Cu(I,j) == 0.0) uhc = uhm

        if (abs(uhc) &lt; 0.1*abs(uhm)) then
          uhm = 10.0*uhc
        elseif (abs(uhc) &gt; c1*abs(uhm)) then
          if (abs(uhc) &lt; c2*abs(uhm)) then ; uhc = (3.0*uhc+(1.0-c2*3.0)*uhm)
          elseif (abs(uhc) &lt;= c3*abs(uhm)) then ; uhc = uhm
          else ; uhc = slope*uhc+(1.0-c3*slope)*uhm
          endif
        endif

        if (uhc &gt; uhm) then
          uh_min(I,j) = uhm ; uh_max(I,j) = uhc
        else
          uh_max(I,j) = uhm ; uh_min(I,j) = uhc
        endif
      enddo ; enddo
      do J=js-1,je ; do i=Isq,Ieq+1
        vhc = vh_center(i,J)
        vhm = vh(i,J,k)
        ! This sometimes matters with some types of open boundary conditions.
        if (G%dx_Cv(i,J) == 0.0) vhc = vhm

        if (abs(vhc) &lt; 0.1*abs(vhm)) then
          vhm = 10.0*vhc
        elseif (abs(vhc) &gt; c1*abs(vhm)) then
          if (abs(vhc) &lt; c2*abs(vhm)) then ; vhc = (3.0*vhc+(1.0-c2*3.0)*vhm)
          elseif (abs(vhc) &lt;= c3*abs(vhm)) then ; vhc = vhm
          else ; vhc = slope*vhc+(1.0-c3*slope)*vhm
          endif
        endif

        if (vhc &gt; vhm) then
          vh_min(i,J) = vhm ; vh_max(i,J) = vhc
        else
          vh_max(i,J) = vhm ; vh_min(i,J) = vhc
        endif
      enddo ; enddo
    endif

    ! Calculate KE and the gradient of KE
    call gradKE(u, v, h, KE, KEx, KEy, k, OBC, G, GV, US, CS)

    ! Calculate the tendencies of zonal velocity due to the Coriolis
    ! force and momentum advection.  On a Cartesian grid, this is
    !     CAu =  q * vh - d(KE)/dx.
    if (CS%Coriolis_Scheme == SADOURNY75_ENERGY) then
      if (CS%Coriolis_En_Dis) then
        ! Energy dissipating biased scheme, Hallberg 200x
        do j=js,je ; do I=Isq,Ieq
          if (q(I,J)*u(I,j,k) == 0.0) then
            temp1 = q(I,J) * ( (vh_max(i,j)+vh_max(i+1,j)) &amp;
                             + (vh_min(i,j)+vh_min(i+1,j)) )*0.5
          elseif (q(I,J)*u(I,j,k) &lt; 0.0) then
            temp1 = q(I,J) * (vh_max(i,j)+vh_max(i+1,j))
          else
            temp1 = q(I,J) * (vh_min(i,j)+vh_min(i+1,j))
          endif
          if (q(I,J-1)*u(I,j,k) == 0.0) then
            temp2 = q(I,J-1) * ( (vh_max(i,j-1)+vh_max(i+1,j-1)) &amp;
                               + (vh_min(i,j-1)+vh_min(i+1,j-1)) )*0.5
          elseif (q(I,J-1)*u(I,j,k) &lt; 0.0) then
            temp2 = q(I,J-1) * (vh_max(i,j-1)+vh_max(i+1,j-1))
          else
            temp2 = q(I,J-1) * (vh_min(i,j-1)+vh_min(i+1,j-1))
          endif
          CAu(I,j,k) = 0.25 * G%IdxCu(I,j) * (temp1 + temp2)
        enddo ; enddo
      else
        ! Energy conserving scheme, Sadourny 1975
        do j=js,je ; do I=Isq,Ieq
          CAu(I,j,k) = 0.25 * &amp;
            (q(I,J) * (vh(i+1,J,k) + vh(i,J,k)) + &amp;
             q(I,J-1) * (vh(i,J-1,k) + vh(i+1,J-1,k))) * G%IdxCu(I,j)
        enddo ; enddo
      endif
    elseif (CS%Coriolis_Scheme == SADOURNY75_ENSTRO) then
      do j=js,je ; do I=Isq,Ieq
        CAu(I,j,k) = 0.125 * (G%IdxCu(I,j) * (q(I,J) + q(I,J-1))) * &amp;
                     ((vh(i+1,J,k) + vh(i,J,k)) + (vh(i,J-1,k) + vh(i+1,J-1,k)))
      enddo ; enddo
    elseif ((CS%Coriolis_Scheme == ARAKAWA_HSU90) .or. &amp;
            (CS%Coriolis_Scheme == ARAKAWA_LAMB81) .or. &amp;
            (CS%Coriolis_Scheme == AL_BLEND)) then
      ! (Global) Energy and (Local) Enstrophy conserving, Arakawa &amp; Hsu 1990
      do j=js,je ; do I=Isq,Ieq
        CAu(I,j,k) = ((a(I,j) * vh(i+1,J,k) +  c(I,j) * vh(i,J-1,k))  + &amp;
                      (b(I,j) * vh(i,J,k) +  d(I,j) * vh(i+1,J-1,k))) * G%IdxCu(I,j)
      enddo ; enddo
    elseif (CS%Coriolis_Scheme == ROBUST_ENSTRO) then
      ! An enstrophy conserving scheme robust to vanishing layers
      ! Note: Heffs are in lieu of h_at_v that should be returned by the
      !       continuity solver. AJA
      do j=js,je ; do I=Isq,Ieq
        Heff1 = abs(vh(i,J,k) * G%IdxCv(i,J)) / (eps_vel+abs(v(i,J,k)))
        Heff1 = max(Heff1, min(h(i,j,k),h(i,j+1,k)))
        Heff1 = min(Heff1, max(h(i,j,k),h(i,j+1,k)))
        Heff2 = abs(vh(i,J-1,k) * G%IdxCv(i,J-1)) / (eps_vel+abs(v(i,J-1,k)))
        Heff2 = max(Heff2, min(h(i,j-1,k),h(i,j,k)))
        Heff2 = min(Heff2, max(h(i,j-1,k),h(i,j,k)))
        Heff3 = abs(vh(i+1,J,k) * G%IdxCv(i+1,J)) / (eps_vel+abs(v(i+1,J,k)))
        Heff3 = max(Heff3, min(h(i+1,j,k),h(i+1,j+1,k)))
        Heff3 = min(Heff3, max(h(i+1,j,k),h(i+1,j+1,k)))
        Heff4 = abs(vh(i+1,J-1,k) * G%IdxCv(i+1,J-1)) / (eps_vel+abs(v(i+1,J-1,k)))
        Heff4 = max(Heff4, min(h(i+1,j-1,k),h(i+1,j,k)))
        Heff4 = min(Heff4, max(h(i+1,j-1,k),h(i+1,j,k)))
        if (CS%PV_Adv_Scheme == PV_ADV_CENTERED) then
          CAu(I,j,k) = 0.5*(abs_vort(I,J)+abs_vort(I,J-1)) * &amp;
                       ((vh(i,J,k) + vh(i+1,J-1,k)) + (vh(i,J-1,k) + vh(i+1,J,k)) ) /  &amp;
                       (h_tiny + ((Heff1+Heff4) + (Heff2+Heff3)) ) * G%IdxCu(I,j)
        elseif (CS%PV_Adv_Scheme == PV_ADV_UPWIND1) then
          VHeff = ((vh(i,J,k) + vh(i+1,J-1,k)) + (vh(i,J-1,k) + vh(i+1,J,k)) )
          QVHeff = 0.5*( (abs_vort(I,J)+abs_vort(I,J-1))*VHeff &amp;
                        -(abs_vort(I,J)-abs_vort(I,J-1))*abs(VHeff) )
          CAu(I,j,k) = (QVHeff / ( h_tiny + ((Heff1+Heff4) + (Heff2+Heff3)) ) ) * G%IdxCu(I,j)
        endif
      enddo ; enddo
    endif
    ! Add in the additonal terms with Arakawa &amp; Lamb.
    if ((CS%Coriolis_Scheme == ARAKAWA_LAMB81) .or. &amp;
        (CS%Coriolis_Scheme == AL_BLEND)) then ; do j=js,je ; do I=Isq,Ieq
      CAu(I,j,k) = CAu(I,j,k) + &amp;
            (ep_u(i,j)*uh(I-1,j,k) - ep_u(i+1,j)*uh(I+1,j,k)) * G%IdxCu(I,j)
    enddo ; enddo ; endif


    if (CS%bound_Coriolis) then
      do j=js,je ; do I=Isq,Ieq
        max_fv = MAX(max_fvq(I,J), max_fvq(I,J-1))
        min_fv = MIN(min_fvq(I,J), min_fvq(I,J-1))
       ! CAu(I,j,k) = min( CAu(I,j,k), max_fv )
       ! CAu(I,j,k) = max( CAu(I,j,k), min_fv )
        if (CAu(I,j,k) &gt; max_fv) then
            CAu(I,j,k) = max_fv
        else
          if (CAu(I,j,k) &lt; min_fv) CAu(I,j,k) = min_fv
        endif
      enddo ; enddo
    endif

    ! Term - d(KE)/dx.
    do j=js,je ; do I=Isq,Ieq
      CAu(I,j,k) = CAu(I,j,k) - KEx(I,j)
      if (associated(AD%gradKEu)) AD%gradKEu(I,j,k) = -KEx(I,j)
</code></pre>
</section>

<section id="coriolis-advection-1" class="title-slide slide level1">
<h1>Coriolis advection</h1>
<pre class=" numberLines" data-code="" data-start-line="669

" data-end-line="694

" data-line-numbers="7-20

" data-startFrom="669

"><code>    ! Add in the additonal terms with Arakawa &amp; Lamb.
    if ((CS%Coriolis_Scheme == ARAKAWA_LAMB81) .or. &amp;
        (CS%Coriolis_Scheme == AL_BLEND)) then ; do j=js,je ; do I=Isq,Ieq
      CAu(I,j,k) = CAu(I,j,k) + &amp;
            (ep_u(i,j)*uh(I-1,j,k) - ep_u(i+1,j)*uh(I+1,j,k)) * G%IdxCu(I,j)
    enddo ; enddo ; endif

    if (CS%bound_Coriolis) then
      do j=js,je ; do I=Isq,Ieq
        fv1 = abs_vort(I,J) * v(i+1,J,k)
        fv2 = abs_vort(I,J) * v(i,J,k)
        fv3 = abs_vort(I,J-1) * v(i+1,J-1,k)
        fv4 = abs_vort(I,J-1) * v(i,J-1,k)

        max_fv = max(fv1, fv2, fv3, fv4)
        min_fv = min(fv1, fv2, fv3, fv4)

        CAu(I,j,k) = min(CAu(I,j,k), max_fv)
        CAu(I,j,k) = max(CAu(I,j,k), min_fv)
      enddo ; enddo
    endif

    ! Term - d(KE)/dx.
    do j=js,je ; do I=Isq,Ieq
      CAu(I,j,k) = CAu(I,j,k) - KEx(I,j)
</code></pre>
</section>

<section id="coriolis-speedup" class="title-slide slide level1">
<h1>Coriolis Speedup</h1>
<table>
<thead>
<tr class="header">
<th>Platform</th>
<th>Old</th>
<th>New</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Gaea</p></td>
<td><p>1.06</p>
<p>(2.79)</p></td>
<td><p>0.87</p>
<p>(3.43)</p></td>
<td><p>1.23x</p></td>
</tr>
<tr class="even">
<td><p>AMD Ryzen 5</p></td>
<td><p>1.11</p>
<p>(2.68)</p></td>
<td><p>0.64</p>
<p>(5.21)</p></td>
<td><p>1.74x</p></td>
</tr>
</tbody>
</table>
</section>

<section id="vertical-viscosity" class="title-slide slide level1">
<h1>Vertical Viscosity</h1>
<pre class=" numberLines" data-code="" data-start-line="1248

" data-end-line="1270

" data-line-numbers="1-23|1|23

" data-startFrom="1248

"><code>  do K=nz,2,-1 ; do i=is,ie ; if (do_i(i)) then
    !    botfn determines when a point is within the influence of the bottom
    !  boundary layer, going from 1 at the bottom to 0 in the interior.
    z2 = z_i(i,k)
    botfn = 1.0 / (1.0 + 0.09*z2*z2*z2*z2*z2*z2)

    if (CS%bottomdraglaw) then
      Kv_tot(i,K) = Kv_tot(i,K) + (kv_bbl(i) - CS%Kv)*botfn
      r = 0.5*(hvel(i,k) + hvel(i,k-1))
      if (r &gt; bbl_thick(i)) then
        h_shear = ((1.0 - botfn) * r + botfn*bbl_thick(i)) + h_neglect
      else
        h_shear = r + h_neglect
      endif
    else
      Kv_tot(i,K) = Kv_tot(i,K) + (CS%Kvbbl-CS%Kv)*botfn
      h_shear = 0.5*(hvel(i,k) + hvel(i,k-1) + h_neglect)
    endif

    ! Calculate the coupling coefficients from the viscosities.
    a_cpl(i,K) = Kv_tot(i,K) / (h_shear*GV%H_to_Z + I_amax*Kv_tot(i,K))
  endif ; enddo ; enddo ! i &amp; k loops
</code></pre>
</section>

<section id="vertical-viscosity-1" class="title-slide slide level1">
<h1>Vertical Viscosity</h1>
<p>TODO: Remove <code>do_I(:)</code></p>
</section>

<section id="vertical-viscosity-speedup" class="title-slide slide level1">
<h1>Vertical Viscosity "speedup"</h1>
<dl>
<dt>Platform GFLOP/s Time</dt>
<dd><p>Old New Old New</p>
</dd>
</dl>
<p>Gaea</p>
<dl>
<dt>AMD Ryzen 5 1.29 2.00 1.54 1.50</dt>
<dd><p>2.50 5.72 0.82 0.68</p>
</dd>
</dl>
</section>

<section id="barotropic-optimization" class="title-slide slide level1">
<h1>Barotropic Optimization</h1>
<pre class=""><code>LOOP BEGIN at ../../ac/../src/core/MOM_barotropic.F90(1491,26)
   remark #15389: vectorization support: reference eta_wtd(i,j) has unaligned access   [ ../      ../ac/../src/core/MOM_barotropic.F90(1492,7) ]
   remark #15381: vectorization support: unaligned access used inside loop body
   remark #15305: vectorization support: vector length 2
   remark #15399: vectorization support: unroll factor set to 2
   remark #15309: vectorization support: normalized vectorization overhead 0.300
   remark #15300: LOOP WAS VECTORIZED
   remark #15451: unmasked unaligned unit stride stores: 1
   remark #15475: --- begin vector cost summary ---
   remark #15476: scalar cost: 4
   remark #15477: vector cost: 2.500
   remark #15478: estimated potential speedup: 1.450
   remark #15488: --- end vector cost summary ---
   remark #25015: Estimate of max trip count of loop=3
LOOP END</code></pre>
</section>

<section id="barotropic-optimization..." class="title-slide slide level1">
<h1>Barotropic Optimization...?</h1>
<pre class=""><code>LOOP BEGIN at ../../ac/../src/core/MOM_barotropic.F90(2383,39)
   remark #25460: No loop optimizations reported
LOOP END</code></pre>
<pre class=""><code>remark #25464: Some optimizations were skipped to constrain compile
   time. Consider overriding limits (-qoverride-limits).</code></pre>
</section>

<section id="barotropic-speedup" class="title-slide slide level1">
<h1>Barotropic Speedup</h1>
<p>Override limits!</p>
<table>
<thead>
<tr class="header">
<th>Platform</th>
<th>Old</th>
<th>New</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Gaea</p></td>
<td><p>2.35</p>
<p>(1.19)</p></td>
<td><p>1.60</p>
<p>(1.74)</p></td>
<td><p>1.46x</p></td>
</tr>
<tr class="even">
<td><p>Ryzen 5</p></td>
<td><p>3.13</p>
<p>(0.89)</p></td>
<td><p>1.66</p>
<p>(1.66)</p></td>
<td><p>1.89x</p></td>
</tr>
</tbody>
</table>
<p>Sustainable solution is to reduce size of <code>btstep()</code></p>
</section>

<section id="barotropic-loop-order" class="title-slide slide level1">
<h1>Barotropic Loop Order</h1>
<ul>
<li>ijk -&gt; kij vectorization</li>
</ul>
<p>(Work in progress!!!)</p>
</section>

<section id="mystery-problems" class="title-slide slide level1">
<h1>Mystery Problems</h1>
<ul>
<li>MOM_hor_visc and the stack</li>
<li></li>
</ul>
</section>

<section id="hierarchy-of-performance" class="title-slide slide level1">
<h1>Hierarchy of Performance</h1>
<ul>
<li><p>Enable vectorization</p>
<ul>
<li class="fragment">Break large loops into smaller loops</li>
<li class="fragment">No conditionals in loops</li>
</ul></li>
</ul>
<ul>
<li><p>Reduce memory-per-loop</p>
<ul>
<li class="fragment"><code>z[:] = a * x[:] + b * y[:]</code> should ideally fit in L1</li>
<li class="fragment">Loop should be pulling the next L2-&gt;L1 update during this loop</li>
<li class="fragment">Eliminate RAM-bound operations (~2GFLOP/s)</li>
</ul></li>
<li><p>Reduce memory access</p>
<ul>
<li class="fragment">i.e. increase arithmetic intensity</li>
<li class="fragment">Avoid deep out-of-order memory access</li>
</ul></li>
<li><p>Align arrays</p>
<ul>
<li>In C, use posix_memalign, not malloc</li>
<li>Actually very difficult in Fortran!</li>
<li>Avoid "peel loops", i.e. overcommit your arrays</li>
</ul></li>
<li><p>Think about algorithm</p>
<ul>
<li>No rules here, just avoid redundant work</li>
</ul></li>
<li><p>Software Engineering matters!</p>
<ul>
<li>Keep functions small (&lt;2000 lines?)</li>
<li>Keep stack variables small (&lt; L2? L3?)</li>
</ul></li>
</ul>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>
  <script src="./reveal.js/plugin/math/math.js"></script>
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/highlight/highlight.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          //TeX: {
          //  inlineMath: [['\\(','\\)']],
          //  displayMath: [['\\[','\\]']],
          //  balanceBraces: true,
          //  processEscapes: false,
          //  processRefs: true,
          //  processEnvironments: true,
          //  preview: 'TeX',
          //  skipTags: ['script','noscript','style','textarea','pre','code'],
          //  ignoreClass: 'tex2jax_ignore',
          //  processClass: 'tex2jax_process'
          //},
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ],
        plugins : [ RevealMath, RevealNotes, RevealHighlight],
      });
    </script>
    </body>
</html>
