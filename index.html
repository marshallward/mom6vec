<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Marshall Ward">
  <meta name="dcterms.date" content="2021-04-21">
  <title>The Vectorization of MOM6</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="./reveal.js/dist/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="./reveal.js/css/theme/gfdl.css" id="theme">
  <!-- Explicitly add zenburn for highlight support -->
  <link rel="stylesheet" href="./reveal.js/plugin/highlight/zenburn.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? './reveal.js/css/print/pdf.scss' : './reveal.js/css/print/paper.scss';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="./reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  <base href="./index.html">
</head>
<body>
  <div class="reveal"
       style="background: url(img/bg_gfdl.jpg);
              background-size: cover;">

    <!-- Original ratio: 10.04" x 7.08" -->
    <div style="height: 100vh; position: absolute; bottom: -50vh; left: -40vh">
      <img style="height: 100vh; width: 142vh" src="img/bg_globe.png">
    </div>

    <header style="width: 10vh; position: absolute; bottom: 2vh; right: 2vh;">
      <img src="img/noaa_logo.png">
    </header>

    <footer style="font-size: 1pc; position: absolute; bottom: 2%; left: 2%;">
      <!-- code>https://marshallward.org/mom6vv</code> -->
      <code><p><a href="https://marshallward.org/ogrp2021.html">https://marshallward.org/ogrp2021.html</a></p></code>
    </footer>

    <div class="slides">

<section id="title-slide">
  <!--div class="reveal" style="text-align: right;">
    <img src="img/noaa_logo.png"
         style="background: none; border: none; box-shadow: none;
         width: 30%"
         alt="NCI">
  </div-->
  <h1 class="title">The Vectorization of MOM6</h1>
  <p class="author" style="text-align: right;">Marshall Ward</p>
  <p class="date" style="text-align: right;">2021-04-21</p>
  <!-- Currently cannot add notes to a title slide, so have to do manually-->
  <aside class="notes">
    
  </aside>
</section>

<section id="peak-performance" class="title-slide slide level1">
<h1>Peak Performance</h1>
<p><span class="math display">\[W \le N \times f \times I_\text{vec}\]</span></p>
<table>
<tbody>
<tr class="odd">
<td><span class="math inline">\(W\)</span></td>
<td>FLOPs per second ("work")</td>
</tr>
<tr class="even">
<td><span class="math inline">\(N\)</span></td>
<td># of CPUs</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(f\)</span></td>
<td>Cycles per second</td>
</tr>
<tr class="even">
<td><span class="math inline">\(I_\text{vec}\)</span></td>
<td>FLOPs per cycle</td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>This is a form of the so-called "iron law" of peak performance.</p>
<p>It is normally written as an expression of time, rather than rate of work, but I think this inverse form is better suited for this discussion.</p>
<p>The "work" here is written as the number of FLOPs (or floating point operations) per second, but it could be generalized to other units computational work.</p>
<p>The first two terms are very straightforward: N is the number of CPUs and f is the clock rate, or cycles per second. More CPUs and faster clock rate means more work.</p>
<p>The third term here is more interesting, and is the focus here. This represents the ability of the CPU to do concurrent work on a single core.</p>
</aside>
</section>

<section>
<section id="cpu-scaling" class="title-slide slide level1">
<h1>CPU Scaling</h1>
<p><img data-src="img/scaling_ocn.svg" alt="image" /></p>
<p>MOM5 scaling in ACCESS-OM2</p>
</section>
<section id="fluid-dynamics-scaling" class="slide level2">
<h2>Fluid Dynamics Scaling</h2>
<p>Tension between local (hyperbolic) solvers</p>
<p><span class="math display">\[\begin{aligned}
\frac{\partial \mathbf{u}}{\partial t}
   &amp;= -\mathbf{u} \cdot \nabla \mathbf{u} - \nabla p + \mathbf{f} \\
\end{aligned}\]</span></p>
<p>and global (elliptic) solvers</p>
<p><span class="math display">\[\begin{aligned}
\nabla^2 p
   &amp;= -\nabla \cdot \left( \mathbf{u} \cdot \nabla \mathbf{u} \right)
      + \nabla \cdot \mathbf{F} \\
   &amp;\approx \nabla \cdot \mathbf{F} \text{(?)} \\
\end{aligned}\]</span></p>
<p>... unless you can cheat (aka oceanography)</p>
</section></section>
<section>
<section id="clock-speed" class="title-slide slide level1">
<h1>Clock Speed</h1>
<p><img data-src="img/clockspeed.svg" style="width:70.0%" alt="image" /></p>
<aside class="notes">
<p>This is a plot of CPU clock speeds from CPUDB. The database goes from about 1970 to 2014, but the situation has not changed much since then.</p>
<p>The trend is clear: Clock speed increased exponentially until about 2005. After that, it flattened out around 3GHz. After that, people stopped talking much about clock speeds.</p>
<p>This is a reflection of Moore's law (transistor rate) but is better explained by the breakdown of Dennard scaling.</p>
<ul>
<li>P ~ f</li>
<li>P/A ~ const</li>
<li>transitor density drops exponentially =&gt; power drops too</li>
<li>=&gt; increase f to balance P</li>
</ul>
<p>After 2005, thermal leakage led to P &gt;&gt; A</p>
</aside>
</section>
<section id="clock-speed-vs-of-cores" class="slide level2">
<h2>Clock Speed vs # of Cores</h2>
<p>Using more cores further reduces clock speed!</p>
</section></section>
<section>
<section id="vectorization" class="title-slide slide level1">
<h1>Vectorization</h1>
<p><img data-src="img/specfp.svg" alt="image" /></p>
<aside class="notes">
<p>:</p>
<p>Main comments:</p>
<ul>
<li><p>Despite the end of clock speed increase, FP rates continue to rise</p></li>
<li><p>But after ~2004, the rate definitely drops. What causes it?</p></li>
<li><p>Less important: What happened in the 90s?</p>
<p>This was the era of high-end vector CPUs (DEC, SPARC, etc). As they failed to keep up with commodity x86 chips, they left the market.</p></li>
<li><p>Even less important: The "blob" at the end is emergence of mobile chips?</p></li>
</ul>
<p>What is SPECfp?</p>
<p>This is a renormalized plot of the SPECfp scores over time.</p>
<p>CPUs are assigned a "score" based on their performance of a suite of FP-based models. The number is somewhat arbitrary.</p>
<p>Unfortunately they periodically change these tests and SPEC strongly discourages comparison across tests, but in the words of Jurgen Willebrand, no one can stop me!</p>
<p>We roughly normalize along Intel trends, especially 95-&gt;2k, which is why the "high end" cloud permeates.</p>
<p>Don't take these numbers too literally, especially my renormalization which I didn't properly calibrate.</p>
</aside>
</section>
<section id="intel-normalization" class="slide level2">
<h2>Intel normalization</h2>
<p><img data-src="img/specfp_intel.svg" alt="image" /></p>
<aside class="notes">
<p>Showing the normalization of Intel-based architectures.</p>
</aside>
</section></section>
<section id="vector-instructions" class="title-slide slide level1">
<h1>Vector Instructions</h1>
<p><img data-src="img/avx.svg" alt="image" /></p>
<table>
<thead>
<tr class="header">
<th>Instr.</th>
<th>Size</th>
<th>GFLOP/s</th>
<th>Obs. (Gaea)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>SSE</td>
<td>4 SP/2 DP</td>
<td>14.4</td>
<td>14.394</td>
</tr>
<tr class="even">
<td>AVX</td>
<td>8 SP/4 DP</td>
<td>28.8</td>
<td>28.790</td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>sse_add GFLOP/s: 14.395 (14.395 / thread) sse_fma GFLOP/s: 28.792 (28.792 / thread) sse_fmac GFLOP/s: 57.576 (57.576 / thread) avx_add GFLOP/s: 28.790 (28.790 / thread) avx_mac GFLOP/s: 57.576 (57.576 / thread) avx_fma GFLOP/s: 57.583 (57.583 / thread)</p>
</aside>
</section>

<section id="fused-multiply-add" class="title-slide slide level1">
<h1>Fused-Multiply Add</h1>
<p>FMA: <span class="math inline">\(d \leftarrow a \times b + c\)</span></p>
<table>
<thead>
<tr class="header">
<th>Instr.</th>
<th>Op</th>
<th>GFLOP/s</th>
<th>Obs.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>SSE</p></td>
<td><p>Add</p>
<p>FMA</p></td>
<td><p>14.4</p>
<p>28.8</p></td>
<td><p>14.394</p>
<p>28.790</p></td>
</tr>
<tr class="even">
<td><p>AVX</p></td>
<td><p>Add</p>
<p>FMA</p></td>
<td><p>28.8</p>
<p>57.6</p></td>
<td><p>28.788</p>
<p>57.580</p></td>
</tr>
</tbody>
</table>
<p><span class="math inline">\(\text{rd}(\text{rd}(a \times b) + c)\)</span> vs <span class="math inline">\(\text{rd}(a \times b + c)\)</span></p>
</section>

<section id="concurrency" class="title-slide slide level1">
<h1>Concurrency</h1>
<p><img data-src="img/broadwell_exc.svg" alt="image" /></p>
<p>2 instr. per cycle, even FMA</p>
</section>

<section id="peak" class="title-slide slide level1">
<h1>Peak</h1>
<table>
<thead>
<tr class="header">
<th>Instr.</th>
<th>Op</th>
<th>GFLOP/s</th>
<th>Obs.</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>SSE</p></td>
<td><p>Add</p>
<p>FMA</p>
<p>2x FMA</p></td>
<td><p>14.4</p>
<p>28.8</p>
<p>57.6</p></td>
<td><p>14.394</p>
<p>28.790</p>
<p>57.580</p></td>
</tr>
<tr class="even">
<td><p>AVX</p></td>
<td><p>Add</p>
<p>Add+Mul</p>
<p>FMA</p>
<p>2x FMA</p></td>
<td><p>28.8</p>
<p>57.6</p>
<p>57.6</p>
<p>115.2</p></td>
<td><p>28.788</p>
<p>57.580</p>
<p>57.580</p>
<p>115.160</p></td>
</tr>
</tbody>
</table>
<aside class="notes">
<p>sse_add GFLOP/s: 14.394 (14.394 / thread) sse_fma GFLOP/s: 28.790 (28.790 / thread) sse_fmac GFLOP/s: 57.580 (57.580 / thread) avx_add GFLOP/s: 28.788 (28.788 / thread) avx_mac GFLOP/s: 57.580 (57.580 / thread) avx_fma GFLOP/s: 57.580 (57.580 / thread) avx_fmac GFLOP/s: 115.160 (115.160 / thread)</p>
</aside>
</section>

<section id="array-ops" class="title-slide slide level1">
<h1>Array Ops</h1>
<p><img data-src="img/gaea_flops.svg" alt="image" /></p>
</section>

<section id="arithmetic-intensity" class="title-slide slide level1">
<h1>Arithmetic Intensity</h1>
<table>
<thead>
<tr class="header">
<th>Expression</th>
<th>AI</th>
<th>GFLOP/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>y[:] = a x[:]</td>
<td>1/4</td>
<td>26.43</td>
</tr>
<tr class="even">
<td>y[:] = x[:] + x[:]</td>
<td>1/4</td>
<td>24.98</td>
</tr>
<tr class="odd">
<td>y[:] = x[:] + y[:]</td>
<td>1/8</td>
<td>18.34</td>
</tr>
<tr class="even">
<td>y[:] = a x[:] + y[:]</td>
<td>1/4</td>
<td>37.58</td>
</tr>
<tr class="odd">
<td>y[:] = a x[:] + b y[:]</td>
<td>3/8</td>
<td>51.08</td>
</tr>
<tr class="even">
<td>y[:] = x[1:] - x[:-1]</td>
<td>1/8</td>
<td>14.07</td>
</tr>
<tr class="odd">
<td>y[:] = x[8:] - x[:-8]</td>
<td>1/8</td>
<td>18.39</td>
</tr>
</tbody>
</table>
</section>

<section id="mom6-sample-config" class="title-slide slide level1">
<h1>MOM6 sample config</h1>
<p>Describe the "benchmark"</p>
</section>

<section id="profiling-with-perf" class="title-slide slide level1">
<h1>Profiling with perf</h1>
<p><img data-src="img/perf_symbols.png" style="width:80.0%" alt="image" /></p>
</section>

<section id="profiling-with-perf-1" class="title-slide slide level1">
<h1>Profiling with perf</h1>
<p><img data-src="img/perf_lines.png" style="width:80.0%" alt="image" /></p>
</section>

<section>
<section id="mom6-flop-rates" class="title-slide slide level1">
<h1>MOM6 FLOP rates</h1>
<table>
<thead>
<tr class="header">
<th>Subroutine</th>
<th>%time</th>
<th>GFLOP/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>btstep</td>
<td>12.94</td>
<td>0.89</td>
</tr>
<tr class="even">
<td>horizontal_viscosity</td>
<td>6.98</td>
<td>2.30</td>
</tr>
<tr class="odd">
<td>vertvisc_coef</td>
<td>6.36</td>
<td>1.29</td>
</tr>
<tr class="even">
<td>coradcalc</td>
<td>4.58</td>
<td>2.68</td>
</tr>
<tr class="odd">
<td>int_density_dz_wright</td>
<td>4.14</td>
<td>8.60</td>
</tr>
<tr class="even">
<td>zonal_flux_adjust</td>
<td>3.59</td>
<td>3.44</td>
</tr>
<tr class="odd">
<td>set_merid_bt_cont</td>
<td>3.41</td>
<td>3.17</td>
</tr>
<tr class="even">
<td>find_coupling_coef</td>
<td>3.40</td>
<td>2.50</td>
</tr>
</tbody>
</table>
</section>
<section id="with-modules..." class="slide level2">
<h2>With modules...</h2>
<table>
<thead>
<tr class="header">
<th>Module</th>
<th>Subroutine</th>
<th>%time</th>
<th>GFLOP/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MOM_barotropic</td>
<td>btstep</td>
<td>12.94</td>
<td>0.89</td>
</tr>
<tr class="even">
<td>MOM_hor_visc</td>
<td>horizontal_viscosity</td>
<td>6.98</td>
<td>2.30</td>
</tr>
<tr class="odd">
<td>MOM_vert_friction</td>
<td>vertvisc_coef</td>
<td>6.36</td>
<td>1.29</td>
</tr>
<tr class="even">
<td>MOM_Coriolisadv</td>
<td>coradcalc</td>
<td>4.58</td>
<td>2.68</td>
</tr>
<tr class="odd">
<td>MOM_EOS_Wright</td>
<td>int_density_dz_wright</td>
<td>4.14</td>
<td>8.60</td>
</tr>
<tr class="even">
<td>MOM_continuity_ppm</td>
<td>zonal_flux_adjust</td>
<td>3.59</td>
<td>3.44</td>
</tr>
<tr class="odd">
<td>MOM_continuity_ppm</td>
<td>set_merid_bt_cont</td>
<td>3.41</td>
<td>3.17</td>
</tr>
<tr class="even">
<td>MOM_vert_friction</td>
<td>find_coupling_coef</td>
<td>3.40</td>
<td>2.50</td>
</tr>
</tbody>
</table>
</section>
<section id="the-rest" class="slide level2">
<h2>The rest</h2>
<table>
<thead>
<tr class="header">
<th>Module</th>
<th>Subroutine</th>
<th>%time</th>
<th>GFLOP/s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MOM_continuity_ppm</td>
<td>zonal_flux_layer</td>
<td><blockquote>
<p>3.29</p>
</blockquote></td>
<td><blockquote>
<p>3.54</p>
</blockquote></td>
</tr>
<tr class="even">
<td>MOM_continuity_ppm</td>
<td>meridional_flux_adjust</td>
<td><blockquote>
<p>3.28</p>
</blockquote></td>
<td><blockquote>
<p>3.95</p>
</blockquote></td>
</tr>
<tr class="odd">
<td>MOM_continuity_ppm</td>
<td>zonal_mass_flux</td>
<td><blockquote>
<p>3.09</p>
</blockquote></td>
<td><blockquote>
<p>3.88</p>
</blockquote></td>
</tr>
<tr class="even">
<td>MOM_dynamics_split_rk2</td>
<td>step_MOM_dyn_split_rk2</td>
<td><blockquote>
<p>3.09</p>
</blockquote></td>
<td><blockquote>
<p>1.31</p>
</blockquote></td>
</tr>
<tr class="odd">
<td>MOM_vert_friction</td>
<td>vertvisc_remnant</td>
<td><blockquote>
<p>2.86</p>
</blockquote></td>
<td><blockquote>
<p>2.16</p>
</blockquote></td>
</tr>
<tr class="even">
<td>MOM_continuity_ppm</td>
<td>ppm_limit_pos</td>
<td><blockquote>
<p>2.72</p>
</blockquote></td>
<td><blockquote>
<p>1.59</p>
</blockquote></td>
</tr>
<tr class="odd">
<td>MOM_continuity_ppm</td>
<td>meridional_mass_flux</td>
<td><blockquote>
<p>2.46</p>
</blockquote></td>
<td><blockquote>
<p>4.16</p>
</blockquote></td>
</tr>
<tr class="even">
<td>mpp_domains_mod</td>
<td>mpp_do_group_update_r8</td>
<td><blockquote>
<p>2.28</p>
</blockquote></td>
<td><blockquote>
<p>0.00</p>
</blockquote></td>
</tr>
<tr class="odd">
<td>MOM_vert_friction</td>
<td>vertvisc</td>
<td><blockquote>
<p>2.00</p>
</blockquote></td>
<td><blockquote>
<p>2.06</p>
</blockquote></td>
</tr>
<tr class="even">
<td>MOM_thickness_diffuse</td>
<td>thickness_diffuse_full</td>
<td><blockquote>
<p>1.92</p>
</blockquote></td>
<td><blockquote>
<p>3.78</p>
</blockquote></td>
</tr>
<tr class="odd">
<td>&lt;runtime&gt;</td>
<td>memset_avx2_unaligned_erms</td>
<td><blockquote>
<p>1.61</p>
</blockquote></td>
<td><blockquote>
<p>0.16</p>
</blockquote></td>
</tr>
<tr class="even">
<td>MOM_barotropic</td>
<td>btcalc</td>
<td><blockquote>
<p>1.45</p>
</blockquote></td>
<td><blockquote>
<p>0.50</p>
</blockquote></td>
</tr>
</tbody>
</table>
</section></section>
<section id="horizontal-viscosity" class="title-slide slide level1">
<h1>Horizontal Viscosity</h1>
<pre class=" numberLines" data-code="" data-start-line="831

" data-end-line="958

" data-line-numbers="1|2-6|7-13|14-18|20-73|127

" data-startFrom="831

"><code>    do j=Jsq,Jeq+1 ; do i=Isq,Ieq+1
      if ((CS%Smagorinsky_Kh) .or. (CS%Smagorinsky_Ah)) then
        Shear_mag = sqrt(sh_xx(i,j)*sh_xx(i,j) + &amp;
          0.25*((sh_xy(I-1,J-1)*sh_xy(I-1,J-1) + sh_xy(I,J)*sh_xy(I,J)) + &amp;
                (sh_xy(I-1,J)*sh_xy(I-1,J) + sh_xy(I,J-1)*sh_xy(I,J-1))))
      endif
      if ((CS%Leith_Kh) .or. (CS%Leith_Ah)) then
        if (CS%use_QG_Leith_visc) then
          vert_vort_mag = MIN(grad_vort_mag_h(i,j) + grad_div_mag_h(i,j),3.*grad_vort_mag_h_2d(i,j))
        else
          vert_vort_mag = (grad_vort_mag_h(i,j) + grad_div_mag_h(i,j))
        endif
      endif
      if (CS%better_bound_Ah .or. CS%better_bound_Kh) then
        hrat_min = min(1.0, min(h_u(I,j), h_u(I-1,j), h_v(i,J), h_v(i,J-1)) / &amp;
                            (h(i,j,k) + h_neglect) )
        visc_bound_rem = 1.0
      endif

      if (CS%Laplacian) then
        ! Determine the Laplacian viscosity at h points, using the
        ! largest value from several parameterizations.
        Kh = CS%Kh_bg_xx(i,j) ! Static (pre-computed) background viscosity
        if (CS%add_LES_viscosity) then
          if (CS%Smagorinsky_Kh) Kh = Kh + CS%Laplac2_const_xx(i,j) * Shear_mag
          if (CS%Leith_Kh) Kh = Kh + CS%Laplac3_const_xx(i,j) * vert_vort_mag*inv_PI3
        else
          if (CS%Smagorinsky_Kh) Kh = max( Kh, CS%Laplac2_const_xx(i,j) * Shear_mag )
          if (CS%Leith_Kh) Kh = max( Kh, CS%Laplac3_const_xx(i,j) * vert_vort_mag*inv_PI3)
        endif
        ! All viscosity contributions above are subject to resolution scaling
        if (rescale_Kh) Kh = VarMix%Res_fn_h(i,j) * Kh
        if (CS%res_scale_MEKE) meke_res_fn = VarMix%Res_fn_h(i,j)
        ! Older method of bounding for stability
        if (legacy_bound) Kh = min(Kh, CS%Kh_Max_xx(i,j))
        Kh = max( Kh, CS%Kh_bg_min ) ! Place a floor on the viscosity, if desired.
        if (use_MEKE_Ku) &amp;
          Kh = Kh + MEKE%Ku(i,j) * meke_res_fn ! *Add* the MEKE contribution (might be negative)
        if (CS%anisotropic) Kh = Kh + CS%Kh_aniso * ( 1. - CS%n1n2_h(i,j)**2 ) ! *Add* the tension component
                                                                               ! of anisotropic viscosity

        ! Newer method of bounding for stability
        if (CS%better_bound_Kh) then
          if (Kh &gt;= hrat_min*CS%Kh_Max_xx(i,j)) then
            visc_bound_rem = 0.0
            Kh = hrat_min*CS%Kh_Max_xx(i,j)
          else
            visc_bound_rem = 1.0 - Kh / (hrat_min*CS%Kh_Max_xx(i,j))
          endif
        endif

        if ((CS%id_Kh_h&gt;0) .or. find_FrictWork .or. CS%debug) Kh_h(i,j,k) = Kh

        if (CS%id_grid_Re_Kh&gt;0) then
          KE = 0.125*((u(I,j,k)+u(I-1,j,k))**2 + (v(i,J,k)+v(i,J-1,k))**2)
          grid_Re_Kh(i,j,k) = (sqrt(KE) * sqrt(CS%grid_sp_h2(i,j))) &amp;
              / max(Kh, CS%min_grid_Kh)
        endif

        if (CS%id_div_xx_h&gt;0) div_xx_h(i,j,k) = div_xx(i,j)
        if (CS%id_sh_xx_h&gt;0) sh_xx_h(i,j,k) = sh_xx(i,j)

        str_xx(i,j) = -Kh * sh_xx(i,j)
      else   ! not Laplacian
        str_xx(i,j) = 0.0
      endif ! Laplacian

      if (CS%anisotropic) then
        ! Shearing-strain averaged to h-points
        local_strain = 0.25 * ( (sh_xy(I,J) + sh_xy(I-1,J-1)) + (sh_xy(I-1,J) + sh_xy(I,J-1)) )
        ! *Add* the shear-strain contribution to the xx-component of stress
        str_xx(i,j) = str_xx(i,j) - CS%Kh_aniso * CS%n1n2_h(i,j) * CS%n1n1_m_n2n2_h(i,j) * local_strain
      endif

      if (CS%biharmonic) then
        ! Determine the biharmonic viscosity at h points, using the
        ! largest value from several parameterizations.
        AhSm = 0.0; AhLth = 0.0
        if ((CS%Smagorinsky_Ah) .or. (CS%Leith_Ah)) then
          if (CS%Smagorinsky_Ah) then
            if (CS%bound_Coriolis) then
              AhSm = Shear_mag * (CS%Biharm_const_xx(i,j) + &amp;
                                  CS%Biharm_const2_xx(i,j)*Shear_mag)
            else
              AhSm = CS%Biharm_const_xx(i,j) * Shear_mag
            endif
          endif
          if (CS%Leith_Ah) AhLth = CS%Biharm6_const_xx(i,j) * abs(Del2vort_h(i,j)) * inv_PI6
          Ah = MAX(MAX(CS%Ah_bg_xx(i,j), AhSm), AhLth)
          if (CS%bound_Ah .and. .not.CS%better_bound_Ah) &amp;
            Ah = MIN(Ah, CS%Ah_Max_xx(i,j))
        else
          Ah = CS%Ah_bg_xx(i,j)
        endif ! Smagorinsky_Ah or Leith_Ah

        if (use_MEKE_Au) Ah = Ah + MEKE%Au(i,j) ! *Add* the MEKE contribution

        if (CS%Re_Ah &gt; 0.0) then
          KE = 0.125*((u(I,j,k)+u(I-1,j,k))**2 + (v(i,J,k)+v(i,J-1,k))**2)
          Ah = sqrt(KE) * CS%Re_Ah_const_xx(i,j)
        endif

        if (CS%better_bound_Ah) then
          Ah = MIN(Ah, visc_bound_rem*hrat_min*CS%Ah_Max_xx(i,j))
        endif

        if ((CS%id_Ah_h&gt;0) .or. find_FrictWork .or. CS%debug) Ah_h(i,j,k) = Ah

        if (CS%id_grid_Re_Ah&gt;0) then
          KE = 0.125*((u(I,j,k)+u(I-1,j,k))**2 + (v(i,J,k)+v(i,J-1,k))**2)
          grid_Re_Ah(i,j,k) = (sqrt(KE) * CS%grid_sp_h3(i,j)) &amp;
              / max(Ah, CS%min_grid_Ah)
        endif

        str_xx(i,j) = str_xx(i,j) + Ah * &amp;
          (CS%DY_dxT(i,j) * (G%IdyCu(I,j)*Del2u(I,j) - G%IdyCu(I-1,j)*Del2u(I-1,j)) - &amp;
           CS%DX_dyT(i,j) * (G%IdxCv(i,J)*Del2v(i,J) - G%IdxCv(i,J-1)*Del2v(i,J-1)))

        ! Keep a copy of the biharmonic contribution for backscatter parameterization
        bhstr_xx(i,j) = Ah * &amp;
          (CS%DY_dxT(i,j) * (G%IdyCu(I,j)*Del2u(I,j) - G%IdyCu(I-1,j)*Del2u(I-1,j)) - &amp;
           CS%DX_dyT(i,j) * (G%IdxCv(i,J)*Del2v(i,J) - G%IdxCv(i,J-1)*Del2v(i,J-1)))
        bhstr_xx(i,j) = bhstr_xx(i,j) * (h(i,j,k) * CS%reduction_xx(i,j))

      endif  ! biharmonic

    enddo ; enddo
</code></pre>
</section>

<section id="non-vectorized-code" class="title-slide slide level1">
<h1>Non-vectorized code</h1>
<pre class="x86asm"><code>│      │833    Shear_mag = sqrt(sh_xx(i,j)*sh_xx(i,j) + &amp;
│ 0.70 │         vaddsd   %xmm13,%xmm12,%xmm14
│ 1.62 │         vsqrtsd  %xmm14,%xmm14,%xmm14
│ 6.53 │         vmovsd   %xmm14,-0x8e8(%rbp)</code></pre>
<table>
<tbody>
<tr class="odd">
<td><code>vaddsd</code></td>
<td>Serial add</td>
</tr>
<tr class="even">
<td><code>vaddpd</code></td>
<td>Parallel add</td>
</tr>
</tbody>
</table>
</section>

<section id="excessive-stack" class="title-slide slide level1">
<h1>Excessive Stack</h1>
<pre class="x86asm"><code>│      │919    Ah = MAX(MAX(CS%Ah_bg_xx(i,j), AhSm), AhLth)
│      │         lea      (%rax,%rdx,8),%rdi
│      │         lea      (%rdi,%rsi,1),%r8
│ 0.39 │         vmovsd   (%r8,%r9,8),%xmm0
│ 0.01 │         vmaxsd   -0x13f8(%rbp),%xmm0,%xmm0
│ 2.34 │         vmaxsd   -0x13f0(%rbp),%xmm0,%xmm0
│ 0.42 │         vmovsd   %xmm0,-0x1468(%rbp)</code></pre>
<table>
<tbody>
<tr class="odd">
<td>lea</td>
<td>Compute mem address</td>
</tr>
<tr class="even">
<td>vmovsd</td>
<td>Serial move</td>
</tr>
<tr class="odd">
<td>vmaxsd</td>
<td>Serial max</td>
</tr>
</tbody>
</table>
</section>

<section id="example-2-coradcalc" class="title-slide slide level1">
<h1>Example 2: CoradCalc</h1>
<ul>
<li>Gather disparate memory accesses</li>
</ul>
</section>

<section id="example-3-vertical-viscosity" class="title-slide slide level1">
<h1>Example 3: Vertical Viscosity</h1>
<ul>
<li>if(do_I(:))</li>
</ul>
</section>

<section id="example-3-btstep" class="title-slide slide level1">
<h1>Example 3: <code>btstep</code></h1>
<ul>
<li>ijk -&gt; kij vectorization</li>
<li>"override_limits"</li>
</ul>
</section>

<section id="mystery-problems" class="title-slide slide level1">
<h1>Mystery Problems</h1>
<ul>
<li>MOM_hor_visc and the stack</li>
<li></li>
</ul>
</section>

<section id="hierarchy-of-performance" class="title-slide slide level1">
<h1>Hierarchy of Performance</h1>
<ul>
<li><p>Enable vectorization</p></li>
<li><p>Eliminate RAM-bound operations (~2GFLOP/s)</p>
<ul>
<li class="fragment">i.e. reduce memory accesses</li>
</ul></li>
<li><p>Think about algorithm</p>
<ul>
<li>Reduce arithmetic intensity</li>
</ul></li>
</ul>
</section>
    </div>
  </div>

  <script src="./reveal.js/dist/reveal.js"></script>
  <script src="./reveal.js/plugin/math/math.js"></script>
  <script src="./reveal.js/plugin/notes/notes.js"></script>
  <script src="./reveal.js/plugin/highlight/highlight.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: true,
        // Push each slide change to the browser history
        history: true,
        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js',
          config: 'TeX-AMS_HTML-full',
          //TeX: {
          //  inlineMath: [['\\(','\\)']],
          //  displayMath: [['\\[','\\]']],
          //  balanceBraces: true,
          //  processEscapes: false,
          //  processRefs: true,
          //  processEnvironments: true,
          //  preview: 'TeX',
          //  skipTags: ['script','noscript','style','textarea','pre','code'],
          //  ignoreClass: 'tex2jax_ignore',
          //  processClass: 'tex2jax_process'
          //},
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: './reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: './reveal.js/plugin/notes/notes.js', async: true }
        ],
        plugins : [ RevealMath, RevealNotes, RevealHighlight],
      });
    </script>
    </body>
</html>
